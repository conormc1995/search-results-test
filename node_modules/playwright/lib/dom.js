"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const mime = require("mime");
const path = require("path");
const util = require("util");
const helper_1 = require("./helper");
const injectedScriptSource = require("./generated/injectedScriptSource");
const js = require("./javascript");
const selectors_1 = require("./selectors");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const progress_1 = require("./progress");
class FrameExecutionContext extends js.ExecutionContext {
    constructor(delegate, frame) {
        super(delegate, frame._page);
        this.frame = frame;
    }
    adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
            return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
    }
    async evaluateInternal(pageFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluate(this, true /* returnByValue */, pageFunction, ...args);
        });
    }
    async evaluateHandleInternal(pageFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluate(this, false /* returnByValue */, pageFunction, ...args);
        });
    }
    createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
            return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
    }
    injectedScript() {
        if (!this._injectedPromise) {
            const custom = [];
            for (const [name, { source }] of selectors_1.selectors._engines)
                custom.push(`{ name: '${name}', engine: (${source}) }`);
            const source = `
        new (${injectedScriptSource.source})([
          ${custom.join(',\n')}
        ])
      `;
            this._injectedPromise = this._delegate.rawEvaluate(source).then(objectId => new js.JSHandle(this, 'object', objectId));
        }
        return this._injectedPromise;
    }
}
exports.FrameExecutionContext = FrameExecutionContext;
class ElementHandle extends js.JSHandle {
    constructor(context, objectId) {
        super(context, 'node', objectId);
        this._objectId = objectId;
        this._context = context;
        this._page = context.frame._page;
    }
    asElement() {
        return this;
    }
    async _evaluateInMain(pageFunction, arg) {
        const main = await this._context.frame._mainContext();
        return main.evaluateInternal(pageFunction, [await main.injectedScript(), this, arg]);
    }
    async _evaluateInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateInternal(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async _evaluateHandleInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateHandleInternal(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
            return null;
        const frame = this._page._frameManager.frame(frameId);
        if (frame)
            return frame;
        for (const page of this._page._browserContext.pages()) {
            const frame = page._frameManager.frame(frameId);
            if (frame)
                return frame;
        }
        return null;
    }
    async contentFrame() {
        const isFrameElement = await this._evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});
        if (!isFrameElement)
            return null;
        return this._page._delegate.getContentFrame(this);
    }
    async getAttribute(name) {
        return this._evaluateInUtility(([injeced, node, name]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                throw new Error('Not an element');
            const element = node;
            return element.getAttribute(name);
        }, name);
    }
    async textContent() {
        return this._evaluateInUtility(([injected, node]) => node.textContent, {});
    }
    async innerText() {
        return this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                throw new Error('Not an element');
            if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml')
                throw new Error('Not an HTMLElement');
            const element = node;
            return element.innerText;
        }, {});
    }
    async innerHTML() {
        return this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                throw new Error('Not an element');
            const element = node;
            return element.innerHTML;
        }, {});
    }
    async dispatchEvent(type, eventInit = {}) {
        await this._evaluateInMain(([injected, node, { type, eventInit }]) => injected.dispatchEvent(node, type, eventInit), { type, eventInit });
    }
    async _scrollRectIntoViewIfNeeded(rect) {
        return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
    }
    async scrollIntoViewIfNeeded() {
        await this._scrollRectIntoViewIfNeeded();
    }
    async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
            return quad.map(point => ({
                x: Math.min(Math.max(point.x, 0), metrics.width),
                y: Math.min(Math.max(point.y, 0), metrics.height),
            }));
        };
        const computeQuadArea = (quad) => {
            // Compute sum of all directed areas of adjacent triangles
            // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
                const p1 = quad[i];
                const p2 = quad[(i + 1) % quad.length];
                area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
            this._page._delegate.getContentQuads(this),
            this._page._delegate.layoutViewport(),
        ]);
        if (!quads || !quads.length)
            return 'invisible';
        const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 1);
        if (!filtered.length)
            return 'outsideviewport';
        // Return the middle point of the first quad.
        const result = { x: 0, y: 0 };
        for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
        }
        return result;
    }
    async _offsetPoint(offset) {
        const [box, border] = await Promise.all([
            this.boundingBox(),
            this._evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(logger_1.logError(this._context._logger)),
        ]);
        if (!box || !border)
            return 'invisible';
        // Make point relative to the padding box to align with offsetX/offsetY.
        return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y,
        };
    }
    async _retryPointerAction(progress, action, options) {
        let first = true;
        while (progress.isRunning()) {
            progress.log(logger_1.apiLog, `${first ? 'attempting' : 'retrying'} ${progress.apiName} action`);
            const result = await this._performPointerAction(progress, action, options);
            if (result === 'done')
                return;
            first = false;
        }
    }
    async _performPointerAction(progress, action, options) {
        const { force = false, position } = options;
        if (!force)
            await this._waitForDisplayedAtStablePositionAndEnabled(progress);
        progress.log(logger_1.apiLog, '  scrolling into view if needed');
        const scrolled = await this._scrollRectIntoViewIfNeeded(position ? { x: position.x, y: position.y, width: 0, height: 0 } : undefined);
        if (scrolled === 'invisible') {
            if (force)
                throw new Error('Element is not visible');
            progress.log(logger_1.apiLog, '  element is not visible');
            return 'retry';
        }
        progress.log(logger_1.apiLog, '  done scrolling');
        const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
        if (maybePoint === 'invisible') {
            if (force)
                throw new Error('Element is not visible');
            progress.log(logger_1.apiLog, '  element is not visibile');
            return 'retry';
        }
        if (maybePoint === 'outsideviewport') {
            if (force)
                throw new Error('Element is outside of the viewport');
            progress.log(logger_1.apiLog, '  element is outside of the viewport');
            return 'retry';
        }
        const point = roundPoint(maybePoint);
        if (!force) {
            if (options.__testHookBeforeHitTarget)
                await options.__testHookBeforeHitTarget();
            progress.log(logger_1.apiLog, `  checking that element receives pointer events at (${point.x},${point.y})`);
            const matchesHitTarget = await this._checkHitTargetAt(point);
            if (!matchesHitTarget) {
                progress.log(logger_1.apiLog, '  element does not receive pointer events');
                return 'retry';
            }
            progress.log(logger_1.apiLog, `  element does receive pointer events, continuing input action`);
        }
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            let restoreModifiers;
            if (options && options.modifiers)
                restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
            progress.log(logger_1.apiLog, `  performing ${progress.apiName} action`);
            await action(point);
            progress.log(logger_1.apiLog, `  ${progress.apiName} action done`);
            progress.log(logger_1.apiLog, '  waiting for scheduled navigations to finish');
            if (options.__testHookAfterPointerAction)
                await options.__testHookAfterPointerAction();
            if (restoreModifiers)
                await this._page.keyboard._ensureModifiers(restoreModifiers);
        }, 'input');
        progress.log(logger_1.apiLog, '  navigations have finished');
        return 'done';
    }
    hover(options = {}) {
        return progress_1.runAbortableTask(progress => this._hover(progress, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    _hover(progress, options) {
        return this._retryPointerAction(progress, point => this._page.mouse.move(point.x, point.y), options);
    }
    click(options = {}) {
        return progress_1.runAbortableTask(progress => this._click(progress, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    _click(progress, options) {
        return this._retryPointerAction(progress, point => this._page.mouse.click(point.x, point.y, options), options);
    }
    dblclick(options = {}) {
        return progress_1.runAbortableTask(progress => this._dblclick(progress, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    _dblclick(progress, options) {
        return this._retryPointerAction(progress, point => this._page.mouse.dblclick(point.x, point.y, options), options);
    }
    async selectOption(values, options = {}) {
        return progress_1.runAbortableTask(progress => this._selectOption(progress, values, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    async _selectOption(progress, values, options) {
        let vals;
        if (!Array.isArray(values))
            vals = [values];
        else
            vals = values;
        const selectOptions = vals.map((value) => typeof value === 'object' ? value : { value });
        for (const option of selectOptions) {
            if (option instanceof ElementHandle)
                continue;
            if (option.value !== undefined)
                helper_1.assert(helper_1.helper.isString(option.value), 'Values must be strings. Found value "' + option.value + '" of type "' + (typeof option.value) + '"');
            if (option.label !== undefined)
                helper_1.assert(helper_1.helper.isString(option.label), 'Labels must be strings. Found label "' + option.label + '" of type "' + (typeof option.label) + '"');
            if (option.index !== undefined)
                helper_1.assert(helper_1.helper.isNumber(option.index), 'Indices must be numbers. Found index "' + option.index + '" of type "' + (typeof option.index) + '"');
        }
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const injectedResult = await this._evaluateInUtility(([injected, node, selectOptions]) => injected.selectOptions(node, selectOptions), selectOptions);
            return handleInjectedResult(injectedResult);
        });
    }
    async fill(value, options = {}) {
        return progress_1.runAbortableTask(progress => this._fill(progress, value, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    async _fill(progress, value, options) {
        progress.log(logger_1.apiLog, `elementHandle.fill("${value}")`);
        helper_1.assert(helper_1.helper.isString(value), 'Value must be string. Found value "' + value + '" of type "' + (typeof value) + '"');
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const poll = await this._evaluateHandleInUtility(([injected, node, value]) => {
                return injected.waitForEnabledAndFill(node, value);
            }, value);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const injectedResult = await pollHandler.finish();
            const needsInput = handleInjectedResult(injectedResult);
            if (needsInput) {
                if (value)
                    await this._page.keyboard.insertText(value);
                else
                    await this._page.keyboard.press('Delete');
            }
        }, 'input');
    }
    async selectText() {
        this._page._log(logger_1.apiLog, `elementHandle.selectText()`);
        const injectedResult = await this._evaluateInUtility(([injected, node]) => injected.selectText(node), {});
        handleInjectedResult(injectedResult);
    }
    async setInputFiles(files, options = {}) {
        return progress_1.runAbortableTask(async (progress) => this._setInputFiles(progress, files, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    async _setInputFiles(progress, files, options) {
        const injectedResult = await this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== 'INPUT')
                return { status: 'error', error: 'Node is not an HTMLInputElement' };
            if (!node.isConnected)
                return { status: 'notconnected' };
            const input = node;
            return { status: 'success', value: input.multiple };
        }, {});
        const multiple = handleInjectedResult(injectedResult);
        let ff;
        if (!Array.isArray(files))
            ff = [files];
        else
            ff = files;
        helper_1.assert(multiple || ff.length <= 1, 'Non-multiple file input can only accept single file!');
        const filePayloads = [];
        for (const item of ff) {
            if (typeof item === 'string') {
                const file = {
                    name: path.basename(item),
                    mimeType: mime.getType(item) || 'application/octet-stream',
                    buffer: await util.promisify(fs.readFile)(item)
                };
                filePayloads.push(file);
            }
            else {
                filePayloads.push(item);
            }
        }
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            await this._page._delegate.setInputFiles(this, filePayloads);
        });
    }
    async focus() {
        this._page._log(logger_1.apiLog, `elementHandle.focus()`);
        const injectedResult = await this._evaluateInUtility(([injected, node]) => injected.focusNode(node), {});
        handleInjectedResult(injectedResult);
    }
    async type(text, options = {}) {
        return progress_1.runAbortableTask(progress => this._type(progress, text, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    async _type(progress, text, options) {
        progress.log(logger_1.apiLog, `elementHandle.type("${text}")`);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            await this.focus();
            await this._page.keyboard.type(text, options);
        }, 'input');
    }
    async press(key, options = {}) {
        return progress_1.runAbortableTask(progress => this._press(progress, key, options), this._page, this._page._timeoutSettings.timeout(options));
    }
    async _press(progress, key, options) {
        progress.log(logger_1.apiLog, `elementHandle.press("${key}")`);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            await this.focus();
            await this._page.keyboard.press(key, options);
        }, 'input');
    }
    async check(options = {}) {
        return progress_1.runAbortableTask(async (progress) => {
            progress.log(logger_1.apiLog, `elementHandle.check()`);
            await this._setChecked(progress, true, options);
        }, this._page, this._page._timeoutSettings.timeout(options));
    }
    async uncheck(options = {}) {
        return progress_1.runAbortableTask(async (progress) => {
            progress.log(logger_1.apiLog, `elementHandle.uncheck()`);
            await this._setChecked(progress, false, options);
        }, this._page, this._page._timeoutSettings.timeout(options));
    }
    async _setChecked(progress, state, options) {
        if (await this._evaluateInUtility(([injected, node]) => injected.isCheckboxChecked(node), {}) === state)
            return;
        await this._click(progress, options);
        if (await this._evaluateInUtility(([injected, node]) => injected.isCheckboxChecked(node), {}) !== state)
            throw new Error('Unable to click checkbox');
    }
    async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
    }
    async screenshot(options) {
        return this._page._screenshotter.screenshotElement(this, options);
    }
    async $(selector) {
        return selectors_1.selectors._query(this._context.frame, selector, this);
    }
    async $$(selector) {
        return selectors_1.selectors._queryAll(this._context.frame, selector, this);
    }
    async $eval(selector, pageFunction, arg) {
        const handle = await selectors_1.selectors._query(this._context.frame, selector, this);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluate(pageFunction, arg);
        handle.dispose();
        return result;
    }
    async $$eval(selector, pageFunction, arg) {
        const arrayHandle = await selectors_1.selectors._queryArray(this._context.frame, selector, this);
        const result = await arrayHandle.evaluate(pageFunction, arg);
        arrayHandle.dispose();
        return result;
    }
    async _waitForDisplayedAtStablePositionAndEnabled(progress) {
        progress.log(logger_1.apiLog, '  waiting for element to be displayed, enabled and not moving');
        const rafCount = this._page._delegate.rafCountForStablePosition();
        const poll = await this._evaluateHandleInUtility(([injected, node, rafCount]) => {
            return injected.waitForDisplayedAtStablePositionAndEnabled(node, rafCount);
        }, rafCount);
        const pollHandler = new InjectedScriptPollHandler(progress, poll);
        const injectedResult = await pollHandler.finish();
        handleInjectedResult(injectedResult);
        progress.log(logger_1.apiLog, '  element is displayed and does not move');
    }
    async _checkHitTargetAt(point) {
        const frame = await this.ownerFrame();
        if (frame && frame.parentFrame()) {
            const element = await frame.frameElement();
            const box = await element.boundingBox();
            if (!box)
                throw new errors_1.NotConnectedError();
            // Translate from viewport coordinates to frame coordinates.
            point = { x: point.x - box.x, y: point.y - box.y };
        }
        const injectedResult = await this._evaluateInUtility(([injected, node, point]) => {
            return injected.checkHitTargetAt(node, point);
        }, point);
        return handleInjectedResult(injectedResult);
    }
}
exports.ElementHandle = ElementHandle;
// Handles an InjectedScriptPoll running in injected script:
// - streams logs into progress;
// - cancels the poll when progress cancels.
class InjectedScriptPollHandler {
    constructor(progress, poll) {
        this._progress = progress;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs(poll.evaluateHandle(poll => poll.logs));
    }
    _streamLogs(logsPromise) {
        // We continuously get a chunk of logs, stream them to the progress and wait for the next chunk.
        logsPromise.catch(e => null).then(logs => {
            if (!logs || !this._poll || !this._progress.isRunning())
                return;
            logs.evaluate(logs => logs.current).catch(e => []).then(messages => {
                for (const message of messages)
                    this._progress.log(logger_1.apiLog, message);
            });
            this._streamLogs(logs.evaluateHandle(logs => logs.next));
        });
    }
    async finishHandle() {
        try {
            const result = await this._poll.evaluateHandle(poll => poll.result);
            await this._finishInternal();
            return result;
        }
        finally {
            this.cancel();
        }
    }
    async finish() {
        try {
            const result = await this._poll.evaluate(poll => poll.result);
            await this._finishInternal();
            return result;
        }
        finally {
            this.cancel();
        }
    }
    async _finishInternal() {
        if (!this._poll)
            return;
        // Retrieve all the logs before continuing.
        const messages = await this._poll.evaluate(poll => poll.takeLastLogs()).catch(e => []);
        for (const message of messages)
            this._progress.log(logger_1.apiLog, message);
    }
    cancel() {
        if (!this._poll)
            return;
        const copy = this._poll;
        this._poll = null;
        copy.evaluate(p => p.cancel()).catch(e => { }).then(() => copy.dispose());
    }
}
exports.InjectedScriptPollHandler = InjectedScriptPollHandler;
function toFileTransferPayload(files) {
    return files.map(file => ({
        name: file.name,
        type: file.mimeType,
        data: file.buffer.toString('base64')
    }));
}
exports.toFileTransferPayload = toFileTransferPayload;
function handleInjectedResult(injectedResult) {
    if (injectedResult.status === 'notconnected')
        throw new errors_1.NotConnectedError();
    if (injectedResult.status === 'error')
        throw new Error(injectedResult.error);
    return injectedResult.value;
}
function roundPoint(point) {
    return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100,
    };
}
//# sourceMappingURL=dom.js.map