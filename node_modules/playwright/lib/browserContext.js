"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
const network = require("./network");
const page_1 = require("./page");
const timeoutSettings_1 = require("./timeoutSettings");
const events_1 = require("./events");
const extendedEventEmitter_1 = require("./extendedEventEmitter");
const logger_1 = require("./logger");
const debugSupport = require("./debug/debugSupport");
class BrowserContextBase extends extendedEventEmitter_1.ExtendedEventEmitter {
    constructor(browserBase, options) {
        super();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._routes = [];
        this._closed = false;
        this._permissions = new Map();
        this._downloads = new Set();
        this._browserBase = browserBase;
        this._options = options;
        this._logger = options.logger ? new logger_1.RootLogger(options.logger) : browserBase;
        this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);
    }
    async _initialize() {
        await debugSupport.installConsoleHelpers(this);
    }
    _abortPromiseForEvent(event) {
        return event === events_1.Events.BrowserContext.Close ? super._abortPromiseForEvent(event) : this._closePromise;
    }
    _getLogger() {
        return this._logger;
    }
    _getTimeoutSettings() {
        return this._timeoutSettings;
    }
    _browserClosed() {
        for (const page of this.pages())
            page._didClose();
        this._didCloseInternal(true);
    }
    async _didCloseInternal(omitDeleteDownloads = false) {
        this._closed = true;
        this.emit(events_1.Events.BrowserContext.Close);
        this._closePromiseFulfill(new Error('Context closed'));
        if (!omitDeleteDownloads)
            await Promise.all([...this._downloads].map(d => d.delete()));
        this._downloads.clear();
    }
    async exposeFunction(name, playwrightFunction) {
        await this.exposeBinding(name, (options, ...args) => playwrightFunction(...args));
    }
    async exposeBinding(name, playwrightBinding) {
        for (const page of this.pages()) {
            if (page._pageBindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        const binding = new page_1.PageBinding(name, playwrightBinding);
        this._pageBindings.set(name, binding);
        this._doExposeBinding(binding);
    }
    async grantPermissions(permissions, options) {
        let origin = '*';
        if (options && options.origin) {
            const url = new URL(options.origin);
            origin = url.origin;
        }
        const existing = new Set(this._permissions.get(origin) || []);
        permissions.forEach(p => existing.add(p));
        const list = [...existing.values()];
        this._permissions.set(origin, list);
        await this._doGrantPermissions(origin, list);
    }
    async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    _isLogEnabled(log) {
        return this._logger._isLogEnabled(log);
    }
    _log(log, message, ...args) {
        return this._logger._log(log, message, ...args);
    }
    async _loadDefaultContext() {
        if (!this.pages().length)
            await this.waitForEvent('page');
        const pages = this.pages();
        await pages[0].waitForLoadState();
        if (pages.length !== 1 || pages[0].url() !== 'about:blank')
            throw new Error(`Arguments can not specify page to be opened (first url is ${pages[0].url()})`);
        if (this._options.isMobile || this._options.locale) {
            // Workaround for:
            // - chromium fails to change isMobile for existing page;
            // - webkit fails to change locale for existing page.
            const oldPage = pages[0];
            await this.newPage();
            await oldPage.close();
        }
    }
    _authenticateProxyViaHeader() {
        const proxy = this._browserBase._options.proxy || { username: undefined, password: undefined };
        const { username, password } = proxy;
        if (username) {
            this._options.httpCredentials = { username, password: password };
            this._options.extraHTTPHeaders = this._options.extraHTTPHeaders || {};
            const token = Buffer.from(`${username}:${password}`).toString('base64');
            this._options.extraHTTPHeaders['Proxy-Authorization'] = `Basic ${token}`;
        }
    }
    _authenticateProxyViaCredentials() {
        const proxy = this._browserBase._options.proxy;
        if (!proxy)
            return;
        const { username, password } = proxy;
        if (username && password)
            this._options.httpCredentials = { username, password };
    }
}
exports.BrowserContextBase = BrowserContextBase;
function assertBrowserContextIsNotOwned(context) {
    for (const page of context.pages()) {
        if (page._ownedContext)
            throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
    }
}
exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
function validateBrowserContextOptions(options) {
    // Copy all fields manually to strip any extra junk.
    // Especially useful when we share context and launch options for launchPersistent.
    const result = {
        ignoreHTTPSErrors: options.ignoreHTTPSErrors,
        bypassCSP: options.bypassCSP,
        locale: options.locale,
        timezoneId: options.timezoneId,
        offline: options.offline,
        colorScheme: options.colorScheme,
        acceptDownloads: options.acceptDownloads,
        viewport: options.viewport,
        javaScriptEnabled: options.javaScriptEnabled,
        userAgent: options.userAgent,
        geolocation: options.geolocation,
        permissions: options.permissions,
        extraHTTPHeaders: options.extraHTTPHeaders,
        httpCredentials: options.httpCredentials,
        deviceScaleFactor: options.deviceScaleFactor,
        isMobile: options.isMobile,
        hasTouch: options.hasTouch,
        logger: options.logger,
    };
    if (result.viewport === null && result.deviceScaleFactor !== undefined)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
    if (result.viewport === null && result.isMobile !== undefined)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
    if (!result.viewport && result.viewport !== null)
        result.viewport = { width: 1280, height: 720 };
    if (result.viewport)
        result.viewport = { ...result.viewport };
    if (result.geolocation)
        result.geolocation = verifyGeolocation(result.geolocation);
    if (result.extraHTTPHeaders)
        result.extraHTTPHeaders = network.verifyHeaders(result.extraHTTPHeaders);
    return result;
}
exports.validateBrowserContextOptions = validateBrowserContextOptions;
function verifyGeolocation(geolocation) {
    const result = { ...geolocation };
    result.accuracy = result.accuracy || 0;
    const { longitude, latitude, accuracy } = result;
    if (!helper_1.helper.isNumber(longitude) || longitude < -180 || longitude > 180)
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
    if (!helper_1.helper.isNumber(latitude) || latitude < -90 || latitude > 90)
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
    if (!helper_1.helper.isNumber(accuracy) || accuracy < 0)
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
    return result;
}
exports.verifyGeolocation = verifyGeolocation;
function verifyProxySettings(proxy) {
    let { server, bypass } = proxy;
    if (!helper_1.helper.isString(server))
        throw new Error(`Invalid proxy.server: ` + server);
    let url = new URL(server);
    if (!['http:', 'https:', 'socks5:'].includes(url.protocol)) {
        url = new URL('http://' + server);
        server = `${url.protocol}//${url.host}`;
    }
    if (bypass)
        bypass = bypass.split(',').map(t => t.trim()).join(',');
    return { ...proxy, server, bypass };
}
exports.verifyProxySettings = verifyProxySettings;
//# sourceMappingURL=browserContext.js.map