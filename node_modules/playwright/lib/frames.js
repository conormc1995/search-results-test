"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util = require("util");
const dom = require("./dom");
const errors_1 = require("./errors");
const events_1 = require("./events");
const helper_1 = require("./helper");
const selectors_1 = require("./selectors");
const types = require("./types");
const hints_1 = require("./hints");
const progress_1 = require("./progress");
const logger_1 = require("./logger");
class FrameManager {
    constructor(page) {
        this._frames = new Map();
        this._consoleMessageTags = new Map();
        this._signalBarriers = new Set();
        this._page = page;
        this._mainFrame = undefined;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
            frames.push(frame);
            for (const subframe of frame.childFrames())
                collect(subframe);
        }
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
            if (this._mainFrame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(this._mainFrame._id);
                this._mainFrame._id = frameId;
            }
            else {
                helper_1.assert(!this._frames.has(frameId));
                this._mainFrame = new Frame(this._page, frameId, parentFrame);
            }
            this._frames.set(frameId, this._mainFrame);
            return this._mainFrame;
        }
        else {
            helper_1.assert(!this._frames.has(frameId));
            const frame = new Frame(this._page, frameId, parentFrame);
            this._frames.set(frameId, frame);
            this._page.emit(events_1.Events.Page.FrameAttached, frame);
            return frame;
        }
    }
    async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        if (noWaitAfter)
            return action();
        const barrier = new SignalBarrier(progress);
        this._signalBarriers.add(barrier);
        if (progress)
            progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
        const result = await action();
        if (source === 'input')
            await this._page._delegate.inputActionEpilogue();
        await barrier.waitFor();
        this._signalBarriers.delete(barrier);
        // Resolve in the next task, after all waitForNavigations.
        await new Promise(helper_1.helper.makeWaitForNextTask());
        return result;
    }
    frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.retain();
    }
    frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.release();
    }
    frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        for (const barrier of this._signalBarriers)
            barrier.addFrameNavigation(frame);
        frame._pendingDocumentId = documentId;
    }
    frameUpdatedDocumentIdForNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._pendingDocumentId = documentId;
    }
    frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        frame._url = url;
        frame._name = name;
        helper_1.debugAssert(!frame._pendingDocumentId || frame._pendingDocumentId === documentId);
        frame._lastDocumentId = documentId;
        frame._pendingDocumentId = '';
        for (const task of frame._frameTasks)
            task.onNewDocument(documentId);
        this.clearFrameLifecycle(frame);
        if (!initial)
            this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._url = url;
        for (const task of frame._frameTasks)
            task.onSameDocument();
        this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, 'domcontentloaded');
        this.frameLifecycleEvent(frameId, 'load');
    }
    frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        if (frame._firedLifecycleEvents.has(event))
            return;
        frame._firedLifecycleEvents.add(event);
        this._notifyLifecycle(frame, event);
        if (frame === this._mainFrame && event === 'load')
            this._page.emit(events_1.Events.Page.Load);
        if (frame === this._mainFrame && event === 'domcontentloaded')
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
    }
    clearFrameLifecycle(frame) {
        frame._firedLifecycleEvents.clear();
        // Keep the current navigation request if any.
        frame._inflightRequests = new Set(Array.from(frame._inflightRequests).filter(request => request._documentId === frame._lastDocumentId));
        frame._stopNetworkIdleTimer();
        if (frame._inflightRequests.size === 0)
            frame._startNetworkIdleTimer();
    }
    requestStarted(request) {
        this._inflightRequestStarted(request);
        for (const task of request.frame()._frameTasks)
            task.onRequest(request);
        if (request._isFavicon) {
            const route = request._route();
            if (route)
                route.continue();
            return;
        }
        this._page._requestStarted(request);
    }
    requestReceivedResponse(response) {
        if (!response.request()._isFavicon)
            this._page.emit(events_1.Events.Page.Response, response);
    }
    requestFinished(request) {
        this._inflightRequestFinished(request);
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFinished, request);
    }
    requestFailed(request, canceled) {
        this._inflightRequestFinished(request);
        if (request._documentId) {
            const isPendingDocument = request.frame()._pendingDocumentId === request._documentId;
            if (isPendingDocument) {
                request.frame()._pendingDocumentId = '';
                let errorText = request.failure().errorText;
                if (canceled)
                    errorText += '; maybe frame was detached?';
                for (const task of request.frame()._frameTasks)
                    task.onNewDocument(request._documentId, new Error(errorText));
            }
        }
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFailed, request);
    }
    provisionalLoadFailed(frame, documentId, error) {
        for (const task of frame._frameTasks)
            task.onNewDocument(documentId, new Error(error));
    }
    _notifyLifecycle(frame, lifecycleEvent) {
        for (let parent = frame; parent; parent = parent.parentFrame()) {
            for (const frameTask of parent._frameTasks)
                frameTask.onLifecycle(frame, lifecycleEvent);
        }
    }
    removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
    }
    _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        this._page.emit(events_1.Events.Page.FrameDetached, frame);
    }
    _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        if (!frame._inflightRequests.has(request))
            return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
            frame._startNetworkIdleTimer();
    }
    _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
            frame._stopNetworkIdleTimer();
    }
    interceptConsoleMessage(message) {
        if (message.type() !== 'debug')
            return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
            return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
    }
}
exports.FrameManager = FrameManager;
class Frame {
    constructor(page, id, parentFrame) {
        this._lastDocumentId = '';
        this._pendingDocumentId = '';
        this._frameTasks = new Set();
        this._url = '';
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = '';
        this._inflightRequests = new Set();
        this._setContentCounter = 0;
        this._detachedCallback = () => { };
        this._id = id;
        this._firedLifecycleEvents = new Set();
        this._page = page;
        this._parentFrame = parentFrame;
        this._detachedPromise = new Promise(x => this._detachedCallback = x);
        this._contextData.set('main', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._contextData.set('utility', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._setContext('main', null);
        this._setContext('utility', null);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    async goto(url, options = {}) {
        const progressController = new progress_1.ProgressController(this._page, this._page._timeoutSettings.navigationTimeout(options));
        abortProgressOnFrameDetach(progressController, this);
        return progressController.run(async (progress) => {
            progress.log(logger_1.apiLog, `navigating to "${url}", waiting until "${options.waitUntil || 'load'}"`);
            const headers = (this._page._state.extraHTTPHeaders || {});
            let referer = headers['referer'] || headers['Referer'];
            if (options.referer !== undefined) {
                if (referer !== undefined && referer !== options.referer)
                    throw new Error('"referer" is already specified as extra HTTP header');
                referer = options.referer;
            }
            url = helper_1.helper.completeUserURL(url);
            const frameTask = new FrameTask(this, progress);
            const sameDocumentPromise = frameTask.waitForSameDocumentNavigation();
            const navigateResult = await this._page._delegate.navigateFrame(this, url, referer).catch(e => {
                // Do not leave sameDocumentPromise unhandled.
                sameDocumentPromise.catch(e => { });
                throw e;
            });
            if (navigateResult.newDocumentId) {
                // Do not leave sameDocumentPromise unhandled.
                sameDocumentPromise.catch(e => { });
                await frameTask.waitForSpecificDocument(navigateResult.newDocumentId);
            }
            else {
                await sameDocumentPromise;
            }
            const request = (navigateResult && navigateResult.newDocumentId) ? frameTask.request(navigateResult.newDocumentId) : null;
            await frameTask.waitForLifecycle(options.waitUntil === undefined ? 'load' : options.waitUntil);
            frameTask.done();
            return request ? request._finalRequest().response() : null;
        });
    }
    async waitForNavigation(options = {}) {
        const progressController = new progress_1.ProgressController(this._page, this._page._timeoutSettings.navigationTimeout(options));
        abortProgressOnFrameDetach(progressController, this);
        return progressController.run(async (progress) => {
            const toUrl = typeof options.url === 'string' ? ` to "${options.url}"` : '';
            progress.log(logger_1.apiLog, `waiting for navigation${toUrl} until "${options.waitUntil || 'load'}"`);
            const frameTask = new FrameTask(this, progress);
            let documentId;
            await Promise.race([
                frameTask.waitForNewDocument(options.url).then(id => documentId = id),
                frameTask.waitForSameDocumentNavigation(options.url),
            ]);
            const request = documentId ? frameTask.request(documentId) : null;
            await frameTask.waitForLifecycle(options.waitUntil === undefined ? 'load' : options.waitUntil);
            frameTask.done();
            return request ? request._finalRequest().response() : null;
        });
    }
    async waitForLoadState(state = 'load', options = {}) {
        const progressController = new progress_1.ProgressController(this._page, this._page._timeoutSettings.navigationTimeout(options));
        abortProgressOnFrameDetach(progressController, this);
        return progressController.run(progress => this._waitForLoadState(progress, state));
    }
    async _waitForLoadState(progress, state) {
        const frameTask = new FrameTask(this, progress);
        await frameTask.waitForLifecycle(state);
        frameTask.done();
    }
    async frameElement() {
        return this._page._delegate.getFrameElement(this);
    }
    _context(contextType) {
        if (this._detached)
            throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(contextType).contextPromise;
    }
    _mainContext() {
        return this._context('main');
    }
    _utilityContext() {
        return this._context('utility');
    }
    async evaluateHandle(pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 2);
        const context = await this._mainContext();
        return context.evaluateHandleInternal(pageFunction, arg);
    }
    async evaluate(pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 2);
        const context = await this._mainContext();
        return context.evaluateInternal(pageFunction, arg);
    }
    async $(selector) {
        return selectors_1.selectors._query(this, selector);
    }
    async waitForSelector(selector, options = {}) {
        if (options.visibility)
            throw new Error('options.visibility is not supported, did you mean options.state?');
        if (options.waitFor && options.waitFor !== 'visible')
            throw new Error('options.waitFor is not supported, did you mean options.state?');
        const { state = 'visible' } = options;
        if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
            throw new Error(`Unsupported waitFor option "${state}"`);
        const { world, task } = selectors_1.selectors._waitForSelectorTask(selector, state);
        return progress_1.runAbortableTask(async (progress) => {
            progress.log(logger_1.apiLog, `waiting for selector "${selector}"${state === 'attached' ? '' : ' to be ' + state}`);
            const result = await this._scheduleRerunnableTask(progress, world, task);
            if (!result.asElement()) {
                result.dispose();
                return null;
            }
            const handle = result.asElement();
            const mainContext = await this._mainContext();
            if (handle && handle._context !== mainContext) {
                const adopted = await this._page._delegate.adoptElementHandle(handle, mainContext);
                handle.dispose();
                return adopted;
            }
            return handle;
        }, this._page, this._page._timeoutSettings.timeout(options));
    }
    async dispatchEvent(selector, type, eventInit, options = {}) {
        const task = selectors_1.selectors._dispatchEventTask(selector, type, eventInit || {});
        return progress_1.runAbortableTask(async (progress) => {
            progress.log(logger_1.apiLog, `Dispatching "${type}" event on selector "${selector}"...`);
            const result = await this._scheduleRerunnableTask(progress, 'main', task);
            result.dispose();
        }, this._page, this._page._timeoutSettings.timeout(options));
    }
    async $eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        const handle = await this.$(selector);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluate(pageFunction, arg);
        handle.dispose();
        return result;
    }
    async $$eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        const arrayHandle = await selectors_1.selectors._queryArray(this, selector);
        const result = await arrayHandle.evaluate(pageFunction, arg);
        arrayHandle.dispose();
        return result;
    }
    async $$(selector) {
        return selectors_1.selectors._queryAll(this, selector);
    }
    async content() {
        const context = await this._utilityContext();
        return context.evaluateInternal(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options = {}) {
        const progressController = new progress_1.ProgressController(this._page, this._page._timeoutSettings.navigationTimeout(options));
        abortProgressOnFrameDetach(progressController, this);
        return progressController.run(async (progress) => {
            const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
            progress.log(logger_1.apiLog, `setting frame content, waiting until "${waitUntil}"`);
            const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
            const context = await this._utilityContext();
            const lifecyclePromise = new Promise((resolve, reject) => {
                this._page._frameManager._consoleMessageTags.set(tag, () => {
                    // Clear lifecycle right after document.open() - see 'tag' below.
                    this._page._frameManager.clearFrameLifecycle(this);
                    this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
                });
            });
            const contentPromise = context.evaluateInternal(({ html, tag }) => {
                window.stop();
                document.open();
                console.debug(tag); // eslint-disable-line no-console
                document.write(html);
                document.close();
            }, { html, tag });
            await Promise.all([contentPromise, lifecyclePromise]);
        });
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    isDetached() {
        return this._detached;
    }
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandleInternal(addScriptUrl, { url, type })).asElement();
            let result;
            if (path !== null) {
                let contents = await util.promisify(fs.readFile)(path, 'utf8');
                contents += '//# sourceURL=' + path.replace(/\n/g, '');
                result = (await context.evaluateHandleInternal(addScriptContent, { content: contents, type })).asElement();
            }
            else {
                result = (await context.evaluateHandleInternal(addScriptContent, { content: content, type })).asElement();
            }
            // Another round trip to the browser to ensure that we receive CSP error messages
            // (if any) logged asynchronously in a separate task on the content main thread.
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
                await context.evaluateInternal(() => true);
            return result;
        });
        async function addScriptUrl(options) {
            const script = document.createElement('script');
            script.src = options.url;
            if (options.type)
                script.type = options.type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(options) {
            const script = document.createElement('script');
            script.type = options.type || 'text/javascript';
            script.text = options.content;
            let error = null;
            script.onerror = e => error = e;
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandleInternal(addStyleUrl, url)).asElement();
            if (path !== null) {
                let contents = await util.promisify(fs.readFile)(path, 'utf8');
                contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
                return (await context.evaluateHandleInternal(addStyleContent, contents)).asElement();
            }
            return (await context.evaluateHandleInternal(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error;
        let cspMessage;
        const actionPromise = new Promise(async (resolve) => {
            try {
                result = await func();
            }
            catch (e) {
                error = e;
            }
            resolve();
        });
        const errorPromise = new Promise(resolve => {
            listeners.push(helper_1.helper.addEventListener(this._page, events_1.Events.Page.Console, (message) => {
                if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
                    cspMessage = message;
                    resolve();
                }
            }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
            throw new Error(cspMessage.text());
        if (error)
            throw error;
        return result;
    }
    async _retryWithSelectorIfNotConnected(selector, options, action) {
        return progress_1.runAbortableTask(async (progress) => {
            while (progress.isRunning()) {
                try {
                    progress.log(logger_1.apiLog, `waiting for selector "${selector}"`);
                    const { world, task } = selectors_1.selectors._waitForSelectorTask(selector, 'attached');
                    const handle = await this._scheduleRerunnableTask(progress, world, task);
                    const element = handle.asElement();
                    progress.cleanupWhenAborted(() => element.dispose());
                    const result = await action(progress, element);
                    element.dispose();
                    return result;
                }
                catch (e) {
                    if (!(e instanceof errors_1.NotConnectedError))
                        throw e;
                    progress.log(logger_1.apiLog, 'element was detached from the DOM, retrying');
                }
            }
            return undefined;
        }, this._page, this._page._timeoutSettings.timeout(options));
    }
    async click(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._click(progress, options));
    }
    async dblclick(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._dblclick(progress, options));
    }
    async fill(selector, value, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._fill(progress, value, options));
    }
    async focus(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle.focus());
    }
    async textContent(selector, options = {}) {
        return await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle.textContent());
    }
    async innerText(selector, options = {}) {
        return await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle.innerText());
    }
    async innerHTML(selector, options = {}) {
        return await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle.innerHTML());
    }
    async getAttribute(selector, name, options = {}) {
        return await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle.getAttribute(name));
    }
    async hover(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._hover(progress, options));
    }
    async selectOption(selector, values, options = {}) {
        return this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._selectOption(progress, values, options));
    }
    async setInputFiles(selector, files, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._setInputFiles(progress, files, options));
    }
    async type(selector, text, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._type(progress, text, options));
    }
    async press(selector, key, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._press(progress, key, options));
    }
    async check(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._setChecked(progress, true, options));
    }
    async uncheck(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (progress, handle) => handle._setChecked(progress, false, options));
    }
    async waitForTimeout(timeout) {
        hints_1.waitForTimeoutWasUsed(this._page);
        await new Promise(fulfill => setTimeout(fulfill, timeout));
    }
    async waitForFunction(pageFunction, arg, options = {}) {
        const { polling = 'raf' } = options;
        if (helper_1.helper.isString(polling))
            helper_1.assert(polling === 'raf', 'Unknown polling option: ' + polling);
        else if (helper_1.helper.isNumber(polling))
            helper_1.assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);
        else
            throw new Error('Unknown polling options: ' + polling);
        const predicateBody = helper_1.helper.isString(pageFunction) ? 'return (' + pageFunction + ')' : 'return (' + pageFunction + ')(arg)';
        const task = async (context) => {
            const injectedScript = await context.injectedScript();
            return context.evaluateHandleInternal(({ injectedScript, predicateBody, polling, arg }) => {
                const innerPredicate = new Function('arg', predicateBody);
                return injectedScript.poll(polling, () => innerPredicate(arg));
            }, { injectedScript, predicateBody, polling, arg });
        };
        return progress_1.runAbortableTask(progress => this._scheduleRerunnableTask(progress, 'main', task), this._page, this._page._timeoutSettings.timeout(options));
    }
    async title() {
        const context = await this._utilityContext();
        return context.evaluateInternal(() => document.title);
    }
    _onDetached() {
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        }
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
    _scheduleRerunnableTask(progress, contextType, task) {
        const data = this._contextData.get(contextType);
        const rerunnableTask = new RerunnableTask(data, progress, task);
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _setContext(contextType, context) {
        const data = this._contextData.get(contextType);
        data.context = context;
        if (context) {
            data.contextResolveCallback.call(null, context);
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.rerun(context);
        }
        else {
            data.contextPromise = new Promise(fulfill => {
                data.contextResolveCallback = fulfill;
            });
        }
    }
    _contextCreated(contextType, context) {
        const data = this._contextData.get(contextType);
        // In case of multiple sessions to the same target, there's a race between
        // connections so we might end up creating multiple isolated worlds.
        // We can use either.
        if (data.context)
            this._setContext(contextType, null);
        this._setContext(contextType, context);
    }
    _contextDestroyed(context) {
        for (const [contextType, data] of this._contextData) {
            if (data.context === context)
                this._setContext(contextType, null);
        }
    }
    _startNetworkIdleTimer() {
        helper_1.assert(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has('networkidle'))
            return;
        this._networkIdleTimer = setTimeout(() => { this._page._frameManager.frameLifecycleEvent(this._id, 'networkidle'); }, 500);
    }
    _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
            clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = undefined;
    }
}
exports.Frame = Frame;
class RerunnableTask {
    constructor(data, progress, task) {
        this._resolve = () => { };
        this._reject = () => { };
        this._task = task;
        this._progress = progress;
        data.rerunnableTasks.add(this);
        this.promise = new Promise((resolve, reject) => {
            // The task is either resolved with a value, or rejected with a meaningful evaluation error.
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    terminate(error) {
        this._reject(error);
    }
    async rerun(context) {
        try {
            const pollHandler = new dom.InjectedScriptPollHandler(this._progress, await this._task(context));
            const result = await pollHandler.finishHandle();
            this._resolve(result);
        }
        catch (e) {
            // When the page is navigated, the promise is rejected.
            // We will try again in the new execution context.
            if (e.message.includes('Execution context was destroyed'))
                return;
            // We could have tried to evaluate in a context which was already
            // destroyed.
            if (e.message.includes('Cannot find context with specified id'))
                return;
            this._reject(e);
        }
    }
}
class SignalBarrier {
    constructor(progress) {
        this._protectCount = 0;
        this._promiseCallback = () => { };
        this._progress = progress;
        this._promise = new Promise(f => this._promiseCallback = f);
        this.retain();
    }
    waitFor() {
        this.release();
        return this._promise;
    }
    async addFrameNavigation(frame) {
        this.retain();
        const frameTask = new FrameTask(frame, this._progress);
        await Promise.race([
            frame._page._disconnectedPromise,
            frame._detachedPromise,
            frameTask.waitForNewDocument(),
            frameTask.waitForSameDocumentNavigation(),
        ]).catch(e => { });
        frameTask.done();
        this.release();
    }
    retain() {
        ++this._protectCount;
    }
    release() {
        --this._protectCount;
        if (!this._protectCount)
            this._promiseCallback();
    }
}
class FrameTask {
    constructor(frame, progress) {
        this._requestMap = new Map();
        this._progress = null;
        this._frame = frame;
        frame._frameTasks.add(this);
        this._progress = progress;
        if (progress)
            progress.cleanupWhenAborted(() => this.done());
    }
    onRequest(request) {
        if (!request._documentId || request.redirectedFrom())
            return;
        this._requestMap.set(request._documentId, request);
    }
    request(documentId) {
        return this._requestMap.get(documentId);
    }
    onSameDocument() {
        if (this._progress)
            this._progress.log(logger_1.apiLog, `navigated to "${this._frame._url}"`);
        if (this._onSameDocument && helper_1.helper.urlMatches(this._frame.url(), this._onSameDocument.url))
            this._onSameDocument.resolve();
    }
    onNewDocument(documentId, error) {
        if (this._progress && !error)
            this._progress.log(logger_1.apiLog, `navigated to "${this._frame._url}"`);
        if (this._onSpecificDocument) {
            if (documentId === this._onSpecificDocument.expectedDocumentId) {
                if (error)
                    this._onSpecificDocument.reject(error);
                else
                    this._onSpecificDocument.resolve();
            }
            else if (!error) {
                this._onSpecificDocument.reject(new Error('Navigation interrupted by another one'));
            }
        }
        if (this._onNewDocument) {
            if (error)
                this._onNewDocument.reject(error);
            else if (helper_1.helper.urlMatches(this._frame.url(), this._onNewDocument.url))
                this._onNewDocument.resolve(documentId);
        }
    }
    onLifecycle(frame, lifecycleEvent) {
        if (this._progress && frame === this._frame && frame._url !== 'about:blank')
            this._progress.log(logger_1.apiLog, `"${lifecycleEvent}" event fired`);
        if (this._onLifecycle && this._checkLifecycleRecursively(this._frame, this._onLifecycle.waitUntil))
            this._onLifecycle.resolve();
    }
    waitForSameDocumentNavigation(url) {
        return new Promise(resolve => {
            helper_1.assert(!this._onSameDocument);
            this._onSameDocument = { url, resolve };
        });
    }
    waitForSpecificDocument(expectedDocumentId) {
        return new Promise((resolve, reject) => {
            helper_1.assert(!this._onSpecificDocument);
            this._onSpecificDocument = { expectedDocumentId, resolve, reject };
        });
    }
    waitForNewDocument(url) {
        return new Promise((resolve, reject) => {
            helper_1.assert(!this._onNewDocument);
            this._onNewDocument = { url, resolve, reject };
        });
    }
    waitForLifecycle(waitUntil) {
        if (waitUntil === 'networkidle0')
            waitUntil = 'networkidle';
        if (!types.kLifecycleEvents.has(waitUntil))
            throw new Error(`Unsupported waitUntil option ${String(waitUntil)}`);
        if (this._checkLifecycleRecursively(this._frame, waitUntil))
            return Promise.resolve();
        return new Promise(resolve => {
            helper_1.assert(!this._onLifecycle);
            this._onLifecycle = { waitUntil, resolve };
        });
    }
    _checkLifecycleRecursively(frame, waitUntil) {
        if (!frame._firedLifecycleEvents.has(waitUntil))
            return false;
        for (const child of frame.childFrames()) {
            if (!this._checkLifecycleRecursively(child, waitUntil))
                return false;
        }
        return true;
    }
    done() {
        this._frame._frameTasks.delete(this);
    }
}
function abortProgressOnFrameDetach(controller, frame) {
    frame._page._disconnectedPromise.then(() => controller.abort(new Error('Navigation failed because browser has disconnected!')));
    frame._detachedPromise.then(() => controller.abort(new Error('Navigating frame was detached!')));
}
//# sourceMappingURL=frames.js.map