"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("./logger");
const errors_1 = require("./errors");
const helper_1 = require("./helper");
const stackTrace_1 = require("./debug/stackTrace");
async function runAbortableTask(task, logger, timeout, apiName) {
    const controller = new ProgressController(logger, timeout, apiName);
    return controller.run(task);
}
exports.runAbortableTask = runAbortableTask;
class ProgressController {
    constructor(logger, timeout, apiName) {
        // Promise and callback that forcefully abort the progress.
        // This promise always rejects.
        this._forceAbort = () => { };
        // Promise and callback that resolve once the progress is aborted.
        // This includes the force abort and also rejection of the task itself (failure).
        this._aborted = () => { };
        // Cleanups to be run only in the case of abort.
        this._cleanups = [];
        this._logRecording = [];
        this._state = 'before';
        this._apiName = apiName || stackTrace_1.getCurrentApiCall();
        this._logger = logger;
        this._timeout = timeout;
        this._deadline = timeout ? monotonicTime() + timeout : 0;
        this._forceAbortPromise = new Promise((resolve, reject) => this._forceAbort = reject);
        this._forceAbortPromise.catch(e => null); // Prevent unhandle promsie rejection.
        this._abortedPromise = new Promise(resolve => this._aborted = resolve);
    }
    async run(task) {
        helper_1.assert(this._state === 'before');
        this._state = 'running';
        const progress = {
            apiName: this._apiName,
            aborted: this._abortedPromise,
            timeUntilDeadline: () => this._deadline ? this._deadline - monotonicTime() : 2147483647,
            isRunning: () => this._state === 'running',
            cleanupWhenAborted: (cleanup) => {
                if (this._state === 'running')
                    this._cleanups.push(cleanup);
                else
                    runCleanup(cleanup);
            },
            log: (log, message) => {
                if (this._state === 'running') {
                    this._logRecording.push(message.toString());
                    this._logger._log(log, '  ' + message);
                }
                else {
                    this._logger._log(log, message);
                }
            },
        };
        this._logger._log(logger_1.apiLog, `=> ${this._apiName} started`);
        const timeoutError = new errors_1.TimeoutError(`Timeout ${this._timeout}ms exceeded during ${this._apiName}.`);
        const timer = setTimeout(() => this._forceAbort(timeoutError), progress.timeUntilDeadline());
        try {
            const promise = task(progress);
            const result = await Promise.race([promise, this._forceAbortPromise]);
            clearTimeout(timer);
            this._state = 'finished';
            this._logRecording = [];
            this._logger._log(logger_1.apiLog, `<= ${this._apiName} succeeded`);
            return result;
        }
        catch (e) {
            this._aborted();
            stackTrace_1.rewriteErrorMessage(e, e.message + formatLogRecording(this._logRecording, this._apiName) + kLoggingNote);
            clearTimeout(timer);
            this._state = 'aborted';
            this._logRecording = [];
            this._logger._log(logger_1.apiLog, `<= ${this._apiName} failed`);
            await Promise.all(this._cleanups.splice(0).map(cleanup => runCleanup(cleanup)));
            throw e;
        }
    }
    abort(error) {
        this._forceAbort(error);
    }
}
exports.ProgressController = ProgressController;
async function runCleanup(cleanup) {
    try {
        await cleanup();
    }
    catch (e) {
    }
}
const kLoggingNote = `\nNote: use DEBUG=pw:api environment variable and rerun to capture Playwright logs.`;
function formatLogRecording(log, name) {
    if (!log.length)
        return '';
    name = ` ${name} logs `;
    const headerLength = 60;
    const leftLength = (headerLength - name.length) / 2;
    const rightLength = headerLength - name.length - leftLength;
    return `\n${'='.repeat(leftLength)}${name}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}
function monotonicTime() {
    const [seconds, nanoseconds] = process.hrtime();
    return seconds * 1000 + (nanoseconds / 1000000 | 0);
}
//# sourceMappingURL=progress.js.map