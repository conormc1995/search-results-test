"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
class Selectors {
    constructor() {
        this._generation = 0;
        // Note: keep in sync with SelectorEvaluator class.
        this._builtinEngines = new Set([
            'css', 'css:light',
            'xpath', 'xpath:light',
            'text', 'text:light',
            'id', 'id:light',
            'data-testid', 'data-testid:light',
            'data-test-id', 'data-test-id:light',
            'data-test', 'data-test:light'
        ]);
        this._engines = new Map();
    }
    async register(name, script, options = {}) {
        const { contentScript = false } = options;
        if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error('Selector engine name may only contain [a-zA-Z0-9_] characters');
        // Note: we keep 'zs' for future use.
        if (this._builtinEngines.has(name) || name === 'zs' || name === 'zs:light')
            throw new Error(`"${name}" is a predefined selector engine`);
        const source = await helper_1.helper.evaluationScript(script, undefined, false);
        if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
        this._engines.set(name, { source, contentScript });
        ++this._generation;
    }
    _needsMainContext(parsed) {
        return parsed.parts.some(({ name }) => {
            const custom = this._engines.get(name);
            return custom ? !custom.contentScript : false;
        });
    }
    async _query(frame, selector, scope) {
        const parsed = this._parseSelector(selector);
        const context = this._needsMainContext(parsed) ? await frame._mainContext() : await frame._utilityContext();
        const injectedScript = await context.injectedScript();
        const handle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelector(parsed, scope || document);
        }, { parsed, scope });
        const elementHandle = handle.asElement();
        if (!elementHandle) {
            handle.dispose();
            return null;
        }
        const mainContext = await frame._mainContext();
        if (elementHandle._context === mainContext)
            return elementHandle;
        const adopted = frame._page._delegate.adoptElementHandle(elementHandle, mainContext);
        elementHandle.dispose();
        return adopted;
    }
    async _queryArray(frame, selector, scope) {
        const parsed = this._parseSelector(selector);
        const context = await frame._mainContext();
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelectorAll(parsed, scope || document);
        }, { parsed, scope });
        return arrayHandle;
    }
    async _queryAll(frame, selector, scope, allowUtilityContext) {
        const parsed = this._parseSelector(selector);
        const context = !allowUtilityContext || this._needsMainContext(parsed) ? await frame._mainContext() : await frame._utilityContext();
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, { parsed, scope }) => {
            return injected.querySelectorAll(parsed, scope || document);
        }, { parsed, scope });
        const properties = await arrayHandle.getProperties();
        arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
            else
                property.dispose();
        }
        return result;
    }
    _waitForSelectorTask(selector, state) {
        const parsed = this._parseSelector(selector);
        const task = async (context) => {
            const injectedScript = await context.injectedScript();
            return injectedScript.evaluateHandle((injected, { parsed, state }) => {
                let lastElement;
                return injected.poll('raf', (progress) => {
                    const element = injected.querySelector(parsed, document);
                    const visible = element ? injected.isVisible(element) : false;
                    if (lastElement !== element) {
                        lastElement = element;
                        if (!element)
                            progress.log(`  selector did not resolve to any element`);
                        else
                            progress.log(`  selector resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewElement(element)}`);
                    }
                    switch (state) {
                        case 'attached':
                            return element || false;
                        case 'detached':
                            return !element;
                        case 'visible':
                            return visible ? element : false;
                        case 'hidden':
                            return !visible;
                    }
                });
            }, { parsed, state });
        };
        return { world: this._needsMainContext(parsed) ? 'main' : 'utility', task };
    }
    _dispatchEventTask(selector, type, eventInit) {
        const parsed = this._parseSelector(selector);
        const task = async (context) => {
            const injectedScript = await context.injectedScript();
            return injectedScript.evaluateHandle((injected, { parsed, type, eventInit }) => {
                return injected.poll('raf', () => {
                    const element = injected.querySelector(parsed, document);
                    if (element)
                        injected.dispatchEvent(element, type, eventInit);
                    return element || false;
                });
            }, { parsed, type, eventInit });
        };
        return task;
    }
    async _createSelector(name, handle) {
        const mainContext = await handle._page.mainFrame()._mainContext();
        const injectedScript = await mainContext.injectedScript();
        return injectedScript.evaluate((injected, { target, name }) => {
            return injected.engines.get(name).create(document.documentElement, target);
        }, { target: handle, name });
    }
    _parseSelector(selector) {
        helper_1.assert(helper_1.helper.isString(selector), `selector must be a string`);
        const parsed = parseSelector(selector);
        for (const { name } of parsed.parts) {
            if (!this._builtinEngines.has(name) && !this._engines.has(name))
                throw new Error(`Unknown engine "${name}" while parsing selector ${selector}`);
        }
        return parsed;
    }
}
exports.Selectors = Selectors;
exports.selectors = new Selectors();
function parseSelector(selector) {
    let index = 0;
    let quote;
    let start = 0;
    const result = { parts: [] };
    const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf('=');
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
            name = part.substring(0, eqIndex).trim();
            body = part.substring(eqIndex + 1);
        }
        else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
            name = 'text';
            body = part;
        }
        else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
            name = 'text';
            body = part;
        }
        else if (/^\(*\/\//.test(part)) {
            // If selector starts with '//' or '//' prefixed with multiple opening
            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
            name = 'xpath';
            body = part;
        }
        else {
            name = 'css';
            body = part;
        }
        name = name.toLowerCase();
        let capture = false;
        if (name[0] === '*') {
            capture = true;
            name = name.substring(1);
        }
        result.parts.push({ name, body });
        if (capture) {
            if (result.capture !== undefined)
                throw new Error(`Only one of the selectors can capture using * modifier`);
            result.capture = result.parts.length - 1;
        }
    };
    while (index < selector.length) {
        const c = selector[index];
        if (c === '\\' && index + 1 < selector.length) {
            index += 2;
        }
        else if (c === quote) {
            quote = undefined;
            index++;
        }
        else if (!quote && (c === '"' || c === '\'' || c === '`')) {
            quote = c;
            index++;
        }
        else if (!quote && c === '>' && selector[index + 1] === '>') {
            append();
            index += 2;
            start = index;
        }
        else {
            index++;
        }
    }
    append();
    return result;
}
exports.parseSelector = parseSelector;
//# sourceMappingURL=selectors.js.map